# Документация по использованию программы генерации и решения лабиринтов

## Описание программы

Данная программа предназначена для генерации случайных лабиринтов различных размеров и поиска кратчайшего пути от начальной точки до конечной. Программа поддерживает несколько алгоритмов генерации и поиска пути, а также возможность модификации лабиринта для добавления сложности. Это позволяет гибко настраивать параметры генерации и поиска решения.

---

## Инструкция по использованию

### Запуск программы

Для начала работы откройте класс `Main` и запустите его. Программа предложит вам ввести необходимые параметры для генерации лабиринта и поиска пути.

### Ввод параметров

После запуска программы вам будет предложено ввести следующие параметры:

1. **Размеры лабиринта**:
    - Введите **ширину** и **высоту** лабиринта (нечетные числа в диапазоне от 5 до 35 включительно).
    - Можно ввести любой символ для выбора случайных значений ширины и высоты.

2. **Алгоритм генерации лабиринта**:
    - Введите **1**, чтобы использовать алгоритм **Recursive Backtracking**.
    - Введите **2**, чтобы использовать алгоритм **Прима**.
    - Введите любой символ для случайного выбора одного из этих алгоритмов.

3. **Алгоритм поиска пути**:
    - Введите **1**, чтобы использовать алгоритм **Поиска в ширину (BFS)**.
    - Введите **2**, чтобы использовать алгоритм **Поиска в глубину (DFS)**.
    - Введите любой символ для случайного выбора одного из этих алгоритмов.

4. **Алгоритм модификации лабиринта**:
    - Введите **YES**, если хотите использовать модификацию лабиринта.
        - Если выбрали **YES**, введите **1** для использования модификации **Non-Ideal Maze Modifier**.
    - Введите **NO** или любой другой символ, если не хотите применять модификации.

5. **Начальная и конечная точки**:
    - Введите координаты начальной и конечной точки в формате: два числа через пробел (например, `0 0` для начальной точки и `4 4` для конечной точки). Координаты должны соответствовать размеру лабиринта.

---

## Описание алгоритмов генерации лабиринта

### **Recursive Backtracking Generator**

Алгоритм рекурсивного поиска пути с возвратом работает следующим образом:
1. Выбирается случайная начальная ячейка.
2. Случайным образом выбирается одна из соседних не посещенных ячеек, к которой можно перейти.
3. Если такая ячейка найдена, делаем её частью лабиринта и переходим к ней, записывая предыдущую ячейку в стек.
4. Если все соседи уже посещены, возвращаемся назад, извлекая ячейки из стека, пока не найдётся не посещённая.
5. Лабиринт завершён, когда в стеке больше не остаётся ячеек для возврата.


### **Алгоритм Прима (Prim Generator)**

Алгоритм Прима использует три типа ячеек для построения лабиринта:
- **Внутренние** — ячейки, которые уже являются частью лабиринта.
- **Граничные** — ячейки, находящиеся рядом с внутренними.
- **Внешние** — ячейки, которые не могут быть частью лабиринта.

1. Выбирается случайная ячейка, которая становится "внутренней".
2. Её соседние ячейки становятся "граничными".
3. Случайно выбирается одна из граничных ячеек, и между ней и одной из соседних внутренних ячеек пробивается стена, делая её внутренней.
4. Процесс повторяется, пока не останется граничных ячеек.


---

## Описание алгоритмов поиска пути

### **Поиск в ширину (BFS Solver)**

Алгоритм BFS (поиск в ширину) работает следующим образом:
1. Начальная точка "заливается" волной: все соседние ячейки помечаются и добавляются в очередь.
2. Волна распространяется на соседние ячейки до тех пор, пока не будут посещены все ячейки.
3. Каждая ячейка запоминает кратчайшее расстояние до стартовой точки.

Затем запускается алгоритм, который идет от конечной точки и ищет клетки с минимальным значением, пока не дойдет до начальной клетки, либо посетит все имеющиеся.
Этот алгоритм всегда находит кратчайший путь, если таковой существует.

### **Поиск в глубину (DFS Solver)**

Алгоритм DFS (поиск в глубину) проходит по лабиринту, двигаясь вдоль одного пути до его конца, затем возвращается к ближайшей точке разветвления, если путь оказался тупиковым.
1. Алгоритм глубоко исследует одно направление, пока не упирается в тупик.
2. Если тупик достигнут, алгоритм возвращается назад и исследует другие пути.
3. Алгоритм посещает все ячейки.
4. Каждая ячейка запоминает кратчайшее расстояние до стартовой точки.

Затем запускается алгоритм, который идет от конечной точки и ищет клетки с минимальным значением, пока не дойдет до начальной клетки, либо посетит все имеющиеся.
Этот алгоритм всегда находит кратчайший путь, если таковой существует.

---

## Описание алгоритмов модификации лабиринта

### **Non-Ideal Maze Modifier**

Этот алгоритм изменяет сгенерированный лабиринт для увеличения его сложности:
1. Собираются координаты всех стен лабиринта.
2. Случайным образом выбирается 5% стен (округлённое вверх количество), и они заменяются на проходы.

Это делает лабиринт менее идеальным, добавляя дополнительные пути и сложности при решении.
